Notes:
-Only 60 requests per second
--Getting best bid or best ask: 1
--Submitting new buy/sell order or amending one buy/sell order: 1
--Submitting new bulk buy/sell order or amending one bulk buy/sell order: number of orders/10
--Cancelling (regardless of size): 1
-If bot idles for 90secs, timed out
-If BitMEX overloads, will send error
-Learn Delta

Config Internal Variables:
walletAmountStandard = 500,
walletAmountCrypto = 500,
currencyStandard = "USD",
currencyCrypto = "XBT",
dataSource = "BitMEX",
waitTime = 1800,
aggressiveness = 0.005,
terminateTime = 60,
lossyShutdown = false
minSpread = 0.5
marketLowThreshold = -0.5
marketHighThreshold = 0.5
relistThreshold = 0.01
minimumPos = 100
maximumPos = -100

DATA---------------------------------------------------------------

Data Internal Variables:
config = {}
numFilledOrders = 0
standardAmount = config["walletAmountStandard"]
cryptoAmount = config["walletAmountCrypto"]
numBuy = 0
numSell = 0
marketTrend = "side"
marketProfit = 0
feeProfit = 0

updateConfigs():
    config = *get json*

rateOfChange():
    avgRate = average rate of change in recentAsks *see panda-test.py* / 100
    if avgRate > ??:
        marketTrend = "High"
    if avgRate < ??:
        marketTrend = "Low"
    else:
        marketTrend = "Side"

BOT--------------------------------------------------------

Bot Internal Variables:
didSomethingHappen = False
didTerminate = False
bestBid = self.updateBid()
bestAsk = self.updateAsk()
spread = bestAsk - bestBid
position = 0
*for all 3 bellow, key is order id and def is the whole json
allOrders = {}
currentOrders = {} *was pastOrder
filledOrders = {}
marketAllOrders = {}
recentAsks = []
lastUpdated = { bestAsk: 0, bestBid: 0, createBulkOrders: 0, amendBulkOrders: 0, get_orders: 0}
toCreate = []
toAmend = []
orderPairs = 6

updateConfigs():
    give the bot config.json

sanitize(response):
    if response is a BitMEX overload error:
        return False
    else:
        return True

sanityCheck:
    if orderManager.bitmex.funds() >= standardAmount + cryptoAmount*in standard*
    if get_orders != allOrders:
        didTerminate = True

updateAsk():
    if (lastUpdated["bestAsk"] - time.time()) > ??:
        ticker = orderManager.get_ticker()
        self.bestAsk = ticker["sell"]
        recentAsks.append(ask)
        if recentAsks.size >= 200:
            del recentAsks[100:]
        lastUpdated["bestAsk"] = time.time()

updateBid():
    if (lastUpdated["bestBid"] - time.time()) > ??:
        ticker = orderManager.get_ticker()
        self.bestBid = ticker["buy"]
        lastUpdated["bestBid"] = time.time()

update()
do as before, but now it also updates lastUpdated

getSpread()
    *does what you think it does*

createOrder(pos):
    newOrder = {}
    if pos >= 0
        newOrder = {'orderID': self.data.orderID, 'orderQty': ??,
                    'price': getOrderPrice(pos), 'side': "Buy"}
    if pos < 0:
        newOrder = {'orderID': self.data.orderID, 'orderQty': ??,
                    'price': getOrderPrice(-pos), 'side': "Sell"}
    self.toCreate.append(newOrder)

amendOrder(order):
    newOrder = {}
    if order["side"] == "Buy":
        newOrder = {'orderID': order["orderID"], 'orderQty': order["orderQty"],
                    'price': self.data.bestBid + orderManager.instrument['tickSize'], 'side': order["side"]}
    if order["side"] == "Sell":
        newOrder = {'orderID': order["orderID"], 'orderQty': order["orderQty"],
                    'price': self.data.bestAsk - orderManager.instrument['tickSize'], 'side': order["side"]}
    self.toAmend.append(newOrder)

getOrderPrice(pos):
    price = bestBid if pos >= 0 else bestAsk
    if pos < 0:
        pos += 1
    else:
        pos -= 1
    return math.toNearest(price*(1+aggressiveness)**pos, orderManager.instrument['tickSize'])

submitOrders():
    if lastUpdated["create_bulk_orders"] - time.time > ??
        orderPos = reversed([for i in range(1, orderPairs)])
        for i in orderPos:
            if not maxPositionCheck():
                createOrder(i)
            if not minPositionCheck()
                createOrder(-i)
        create_bulk_orders([toCreate])
        reviseOrders()

reviseOrders()
    if lastUpdated["create_bulk_orders"] - time.time > ??
        for amended_order in toAmend:
            current_order = order with same id in currentOrders
            if not abs((amended_order['price'] / current_order['price']) - 1) > relistThreshold:
                toAmend.remove(amended_order)
        amend_bulk_orders([toAmend])

highestBuyOrder()
    *The buy order in currentOrders with the highest price*

lowestSellOrder()
    *The sell order in currentOrders with the lowest price*

localUpdate():
    marketAllOrder = get_orders
    for order in marketAllOrder:
        if order['side'] == "Sell" & order['ordStatus'] == "Filled:":
            self.data.numBuy += 1
            self.data.standardAmount -= order.price
            self.data.cryptoAmount += order.quantity
            self.data.pastOrders.remove(self.data.orderID)
        if order['side'] == "Buy" & order['ordStatus'] == "Filled:":
            self.data.numSell += 1
            self.data.standardAmount += order.price
            self.data.cryptoAmount -= order.quantity
            self.data.pastOrders.remove(self.data.orderID)

*do something with this*
temp = (bitmex.funds() // bestAsk) // 2             *// is int division*
    if temp > 10:
        orderQty = 10
    elif temp < 3:
        shutdown and send an error "inadequate funds"

minPositionCheck():
    if orderManager.exchange.get_delta <= minPosition
        return true
    return false

maxPositionCheck():
    if orderManager.exchange.get_delta >= maxPosition
        return true
    return false

run():
    while not terminated {
        updateAsk()
        updateBid()
        rateofChange()
        if marketTrend == "Low":
            position = 1
        else if marketTrend == "High"
            recentRateOfChange = *rate of change of last 10 entries in recentAsks*
            if recentMarketTrend > .015:
                position = -1
        else :
            submitOrders()